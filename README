Data::Alias 0.06 -- No-copy variable manipulation

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install


Module documentation:

NAME
    Data::Alias - Comprehensive set of aliasing operations

SYNOPSIS
        use Data::Alias;

        alias $x = $y;              # alias $x to $y
        alias $x[0] = $y;           # similar for array and hash elements
        alias push @x, $y;          # push alias to $y onto @x
        $x = alias [ $y, $z ];      # construct array of aliases
        alias my ($x, $y) = @_;     # named aliases to sub args
        alias { ($x, $y) = ($y, $x) };              # swap $x and $y
        alias { my @tmp = @x; @x = @y; @y = @tmp }; # swap @x and @y

        use Data::Alias qw(deref);

        my @refs = (\$x, \@y);
        $_++ for deref @refs;       # dereference a list of references

        # Note that I omitted \%z from the @refs because $_++ would fail 
        # on a key, but deref does work on hash-refs too of course.

DESCRIPTION
    This module contains functions to work with variables without copying
    data around. You can use them for efficiency, or because you desire the
    aliasing that occurs instead of copying.

    The main function of this module is "alias", which is actually a special
    kind of operator which applies alias semantics to the evaluation of
    its argument list. Another function, "copy", restores the normal
    semantics and makes a copy of the result list. Both are exported by
    default.

    The utility function "deref" is not exported by default.

  alias LIST
    Evaluates the list with alias semantics, which just means that the
    behavior of various kinds of operations is overridden as described
    below. The alias semantics propagate into inner lexical (but not
    dynamic) scopes, including anonymous subroutines, but can be temporarily
    disabled with "copy".

    An "alias" expression can be used as lvalue, though you will of course
    then receive a runtime error if the results are in fact read-only.

    Alias semantics of operations:

    scalar assignment to variable or element.
        Makes the assignment target an alias to the result of the right-hand
        side expression. Works for package variables, lexical variables,
        array elements, hash elements, and pseudo-hash elements.

    scalar assignment to dereference ("$$x = ...")
        Makes $$x an alias to the result of the right-hand side expression
        as follows: if $x is a reference or undef, then $x is simply changed
        to reference the RHS result. Otherwise the indicated package
        variable (via glob or symbolic reference) is aliased.

    scalar assignment to glob ("*x = ...")
        Works mostly as normal glob-assignment, since this is already
        aliasing behavior, however it does not set the import-flag.

    scalar assignment to anything else
        Not supported.

    conditional scalar assignment ("&&=", "||=")
        These work as you'd expect: they conditionally alias the target
        variable, depending on the truth of the current value of the target.

        You can also place a conditional expression ("? :") on the left side
        of an assignment.

    list assignment to whole aggregate ("@x = ...", "%x = ...")
        Normally list assignment aliases the contents of an array or hash,
        however if the left-hand side is a bare unparenthesized variable or
        dereference, the whole thing is aliased. That is, "alias @x = @y"
        will make "\@x == \@y".

        If the right-hand side expression is not an aggregate of the same
        type, a new anonymous array or hash is created and used as variable
        to alias to.

    list assignment, all other cases
        Behaves like usual list-assignment, except scalars are aliased over
        to their destination, rather than copied. The left-hand side list
        can contain valid scalar targets, slices, and whole arrays, hashes,
        and pseudo-hashes.

    "push", "unshift", "splice", "[ ... ]", "{ ... }"
        Array operations and anonymous array and hash constructors work as
        usual, except the new elements are aliases rather than copies.

    "return", including implicit return from "sub" or "eval"
        Returns aliases (rather than copies) from the current "sub" or
        "eval".

    "do { ... }", and hence also "alias { ... }"
        Yields aliases (rather than copies) of the result expression. In
        addition, an "alias { ... }" expression is usable as lvalue (though
        with the assignment outside "alias", it will not cause aliasing).

  alias BLOCK
    "alias { ... }" is shorthand for "alias(do { ... })". Note that no
    further arguments are expected, so "alias { ... }, LIST" is parsed as
    "alias(do { ... }), LIST".

  copy LIST
    Makes a copy of the list of values. The list of arguments is evaluated
    with normal semantics, even when nested inside "alias".

  copy BLOCK
    "copy { ... }" is shorthand for "copy(do { ... })".

  deref LIST
    Dereferences a list of scalar refs, array refs and hash refs. Mainly
    exists because you can't use "map" for this application, as it makes
    copies of the dereferenced values.

AUTHOR
    Matthijs van Duin <xmath@cpan.org>

    Copyright (C) 2003, 2004, 2006 Matthijs van Duin. All rights reserved.
    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

